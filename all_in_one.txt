// File: ./cmd/main.go
package main

import (
	"fmt"
	"navi/internal/users" // Ensure this import path is correct based on your project structure
	"os"

	"fyne.io/fyne/v2"
	"fyne.io/fyne/v2/app"
	"fyne.io/fyne/v2/container"
	"fyne.io/fyne/v2/dialog"
	"fyne.io/fyne/v2/widget"
)

func main() {
	// It's good practice to separate app initialization and window creation into their own functions for better readability and maintenance.
	myApp := app.New()
	myWindow := createRegistrationWindow(myApp)

	myWindow.ShowAndRun()
}

func createRegistrationWindow(app fyne.App) fyne.Window {
	myWindow := app.NewWindow("Register")

	// Consider moving user service initialization outside of your main or UI logic if it's used in multiple places or requires initial setup.
	directusURL := os.Getenv("DIRECTUS_URL")
	directusEmail := os.Getenv("DIRECTUS_EMAIL")
	directusPassword := os.Getenv("DIRECTUS_PASSWORD")

	userService := users.NewUserService(directusURL, directusEmail, directusPassword)

	emailEntry := widget.NewEntry()
	emailEntry.SetPlaceHolder("Email")

	passwordEntry := widget.NewPasswordEntry()
	passwordEntry.SetPlaceHolder("Password")

	registerBtn := widget.NewButton("Register", func() {
		registerUser(userService, emailEntry.Text, passwordEntry.Text, myWindow)
	})

	myWindow.SetContent(container.NewVBox(
		emailEntry,
		passwordEntry,
		registerBtn,
	))

	return myWindow
}

// Separating the user registration logic into its own function improves readability and makes the code easier to manage.
func registerUser(userService *users.UserService, email, password string, window fyne.Window) {
	token, err := userService.Authenticate()
	if err != nil {
		dialog.ShowError(fmt.Errorf("Authentication failed: %v", err), window)
		return
	}

	userID, err := userService.CreateUser(token, email, password)
	if err != nil {
		dialog.ShowError(fmt.Errorf("Failed to create user: %v", err), window)
		return
	}

	dialog.ShowInformation("Success", fmt.Sprintf("User created successfully. User ID: %s", userID), window)
}

// End of ./cmd/main.go

// File: ./pkg/directus/directus.go
package directus

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
)

type Client struct {
	URL      string
	Email    string
	Password string
}

type AuthResponse struct {
	Data struct {
		AccessToken string `json:"access_token"`
	} `json:"data"`
}

type CreateUserResponse struct {
	Data struct {
		ID string `json:"id"`
	} `json:"data"`
}

func NewClient(url, email, password string) *Client {
	return &Client{
		URL:      url,
		Email:    email,
		Password: password,
	}
}

func (c *Client) Authenticate() (string, error) {
	authData := map[string]string{
		"email":    c.Email,
		"password": c.Password,
	}
	authDataBytes, _ := json.Marshal(authData)
	resp, err := http.Post(c.URL+"/auth/login", "application/json", bytes.NewBuffer(authDataBytes))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var authResp AuthResponse
	if err := json.NewDecoder(resp.Body).Decode(&authResp); err != nil {
		return "", err
	}

	return authResp.Data.AccessToken, nil
}

func (c *Client) CreateUser(token, email, password string) (string, error) {
	userData := map[string]interface{}{
		"email":    email,    // Use parameter
		"password": password, // Use parameter
	}
	userDataBytes, _ := json.Marshal(userData)

	req, _ := http.NewRequest("POST", c.URL+"/users", bytes.NewBuffer(userDataBytes))
	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 200 && resp.StatusCode < 300 {
		var createUserResp CreateUserResponse
		if err := json.NewDecoder(resp.Body).Decode(&createUserResp); err != nil {
			return "", err
		}
		return createUserResp.Data.ID, nil
	} else {
		bodyBytes, _ := ioutil.ReadAll(resp.Body)
		return "", fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(bodyBytes))
	}
}

// End of ./pkg/directus/directus.go

// File: ./internal/users/users.go
// Contents of /internal/users/users.go
package users

import (
	"navi/pkg/directus" // Update this import path to match your module's actual path
)

type UserService struct {
	DirectusClient *directus.Client
}

func NewUserService(directusURL, adminEmail, adminPassword string) *UserService {
	return &UserService{
		DirectusClient: directus.NewClient(directusURL, adminEmail, adminPassword),
	}
}

func (s *UserService) Authenticate() (string, error) {
	return s.DirectusClient.Authenticate()
}

func (s *UserService) CreateUser(token, email, password string) (string, error) {
	// Modified to pass email and password as parameters
	return s.DirectusClient.CreateUser(token, email, password)
}

// End of ./internal/users/users.go

